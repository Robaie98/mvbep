<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>mvbep API documentation</title>
<meta name="description" content="Measurement and Verification Building Energy Prediction (MVBEP) is a `class` that encompasses different
modules for reading and validating input data â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>mvbep</code></h1>
</header>
<section id="section-intro">
<p>Measurement and Verification Building Energy Prediction (MVBEP) is a <code>class</code> that encompasses different
modules for reading and validating input data to transforming such data and using them to develop regression
models for savings estimations in the post-retrofit period. </p>
<p>The <code>class</code> is fitted by using <code>fit_training()</code> which takes in the required input data. Followingly, an
initialization summary is produced to check the data sufficiency requirements or the need for any actions
to fix the input data. If the data met the requirements to build a model, the function <code>develop_mvbep()</code>
is used to transform the data, train, and evaluate regression models. <code>GenerateDevelopmentSummary()</code> function
can be used to see the summary of the development process. Finally, savings are estimated passing using post-retrofit
data to <code>predict_energy_consumption()</code> function. The current state of the documentation covers only <code><a title="mvbep.MVBEP" href="#mvbep.MVBEP">MVBEP</a></code> class.
Future additions to the project includes writing the documentation for the remaining modules (i.e. <code>Initializer</code>,
<code>Transformer</code>, <code>Developer</code>, 'Interpreter', and 'Writer').</p>
<p>Please check the provided Notebooks for the package demonstration.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Measurement and Verification Building Energy Prediction (MVBEP) is a `class` that encompasses different
modules for reading and validating input data to transforming such data and using them to develop regression
models for savings estimations in the post-retrofit period. 

The `class` is fitted by using `fit_training()` which takes in the required input data. Followingly, an
initialization summary is produced to check the data sufficiency requirements or the need for any actions
to fix the input data. If the data met the requirements to build a model, the function `develop_mvbep()`
is used to transform the data, train, and evaluate regression models. `GenerateDevelopmentSummary()` function 
can be used to see the summary of the development process. Finally, savings are estimated passing using post-retrofit
data to `predict_energy_consumption()` function. The current state of the documentation covers only `MVBEP` class.
Future additions to the project includes writing the documentation for the remaining modules (i.e. `Initializer`,
`Transformer`, `Developer`, &#39;Interpreter&#39;, and &#39;Writer&#39;).

Please check the provided Notebooks for the package demonstration.

&#34;&#34;&#34;


from datetime import datetime
import tracemalloc
import pandas as pd

# from .initializer import Initializer
# from .transformer import Transformer
# from .developer import Developer

# import sys

# from .writer import GenerateInitializationSummary, GenerateMVBEPSummary, GenerateQuantificationSummary
# from .interpreter import return_interpretation_data

import sys
import os
import joblib


class MVBEP:
    &#34;&#34;&#34; MVBEP class to perform all steps of building an energy consumption baseline. 

        The class incorporates the 4 required modules for building a baseline starting 
        from initialization to savings quantification.

        Parameters
        ----------
        mvbep_state_path : str:  (Default value = None)  
            The file path for a saved MVBEP state in case the baseline creation process 
            stopped before the final step and saved by `save_mvbep_state()`.

        Attributes
        ----------
        mvbep_state : dict:  
            A python object that saves all the required information for either continuing
            the process of MVBEP or quantifying savings when the MVBEP object is developed. 
            [Check MVBEP state structure](??) 


        Example
        ----------
        In case a object of MVBEP was saved by using `save_mvbep_state` before, it can be loaded like
        ```
        mvbep_boulder = MVBEP(mvbep_state_path = &#39;mvbep_states/office-boulder_mvbep-state&#39;)
        ```

        In case there was no object saved before, an instance of MVBEP is created by
        ```
        mvbep_boulder = MVBEP()
        ```

    &#34;&#34;&#34;
    def __init__(self, mvbep_state_path:str=None):
        self.mvbep_state = {
            &#39;mvbep&#39;:{
                &#39;date&#39;             : str(datetime.now().strftime(&#34;%Y%m%d-%H%M%S&#34;)),
                &#39;version&#39;          : 1.0,
                &#39;best_model&#39;       : None,
                &#39;development_state&#39;: &#39;NOT INITIATED&#39;
            },
            
            &#39;initializer&#39;:{
                &#39;cleaned_data&#39;              : None,
                &#39;frequency&#39;                 : None,
                &#39;features&#39;                  : None,
                &#39;country_code&#39;              : None,
                &#39;df_validation&#39;             : None,
                &#39;data_sufficiency&#39;          : None,
                &#39;occupancy_schedule&#39;        : None,
                &#39;df_timestamps_highlights&#39;  : None
            },

            &#39;transformer&#39;:{
                &#39;mvbep_frequency&#39;               : None,
                &#39;design_matrices_features&#39;      : None
            },
            
            &#39;developer&#39;:{
                &#39;training_inputs&#39;:{
                    &#39;modeling_methods&#39;      : None,
                    &#39;test_size&#39;             : None,
                    &#39;hyperparameter_tuning&#39; : None,
                    &#39;ranking_method&#39;        : None
                },
                &#39;training_outputs&#39;:{
                    &#39;training_summary&#39;: None,
                    &#39;frequency&#39;:{
                        &#39;15-min&#39;:{
                            &#39;models_dict&#39; : None,
                            &#39;summary&#39;:{
                                &#39;evaluation&#39;: None, 
                                &#39;plot_data&#39; : None
                            }
                        },
                        &#39;hourly&#39;:{
                            &#39;models_dict&#39; : None,
                            &#39;summary&#39;:{
                                &#39;evaluation&#39;: None, 
                                &#39;plot_data&#39; : None
                            }
                        },
                        &#39;daily&#39;: {
                            &#39;models_dict&#39; : None,
                            &#39;summary&#39;:{
                                &#39;evaluation&#39;: None, 
                                &#39;plot_data&#39; : None
                            }
                        }
                    }
                }
            }
        }
        

        if mvbep_state_path is not None:  
            with open(mvbep_state_path, &#39;rb&#39;) as f:
                self.mvbep_state = joblib.load(f)
        else:
            pass


    def fit_training(self,
                    data:pd.DataFrame,
                    frequency:str,
                    country_code:str = None,
                    occupancy_schedule:dict = None,
                    mismatch_date_threshold:float = 0.3,
                    total_missing = None,
                    max_consec_missing = None, 
                    n_days = 360
    ): 
        &#34;&#34;&#34; Fits a MVBEP object with raw data. 

        This is the first method in developing an energy consumption baseline. The
        method takes required historical data to prepare them for next processes. 

        Parameters
        ----------
        data : pd.DataFrame:   
            A dataframe that includes the required data which includes at least 
            
            - Timestamps in 15-min or hourly intervals
            - Energy consumption
            - Outdoor dry-bulb temperature
        frequency : str: {&#39;15-min&#39;, &#39;hourly&#39;}
            The timestamps intervals frequency.
        country_code : str: (default `None`)
            A two-letter `str` indicating the country code in which the building resides.
            The supported codes are listed in holiday package [documentation](https://pypi.org/project/holidays/)
        occupancy_schedule : dict: (default `None`)
            A `dict` indicating the general occupancy density in the building. [Check
            the parameter structure ](??)
        mismatch_date_threshold : float: (default = 0.3)
            Sets the threshold for values in `timestamp` column that cannot be converted from `str`
            to `datetime` object.  
        total_missing : int: (default `None`, The value is set based on frequency)
            Sets a threshold for the total number of a feature&#39;s missing observations to meet 
            data sufficiency requirements.
        max_consec_missing : int: (default `None`, The value is set based on frequency)
            Sets a threshold for consecutive missing observations in a single feature before
            the feature is dropped.
        n_days : int: (default 365)
            Sets a threshold for the least number of days in `data`. 

        Example
        ----------
        Example of a building located in Boulder, CO, USA with hourly timestamps. The instance of MVBEP
        was created with a nmae of `mvbep_boulder`.
        ```
        mvbep_boulder.fit_training(
            data = df_boulder_office, 
            frequency = &#39;hourly&#39;,
            country_code = &#39;US&#39;
        )

        ```


        &#34;&#34;&#34;
        # Checking the MVBEP object state
        if self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] != &#39;NOT INITIATED&#39;:
            if self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] == &#39;DEVELOPED&#39;:
                print(&#34;The MVBEP started the initiation process and finished developing a MVBEP model. To predict baseline values run predict_energy_consumption()&#34;)
                sys.exit()
            else:
                print(&#34;The MVBEP started the initiation but didn&#39;t start developing a MVBEP model. To start development run develop_mvbep()&#34;)
                sys.exit()

        # Creating an initializer and validating the passed data
        initializer = Initializer(mismatch_date_threshold = mismatch_date_threshold)
        initializer.fit(data = data,
                        frequency = frequency,
                        country_code = country_code,
                        occupancy_schedule = occupancy_schedule
                        )
        initializer.validate(total_missing = total_missing, 
                            max_consec_missing = max_consec_missing,
                            n_days = n_days
                            )
        
        # Updating the MVBEP object state
        if initializer.data_sufficiency:
            self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;]  = &#39;INITIATED&#39;
        else: 
            self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;]  = &#39;FAILED INITIATION&#39;
        self.mvbep_state[&#39;initializer&#39;][&#39;cleaned_data&#39;]             = initializer.df_fin
        self.mvbep_state[&#39;initializer&#39;][&#39;frequency&#39;]                = initializer.frequency
        self.mvbep_state[&#39;initializer&#39;][&#39;features&#39;]                 = initializer.features
        self.mvbep_state[&#39;initializer&#39;][&#39;country_code&#39;]             = initializer.country_code
        self.mvbep_state[&#39;initializer&#39;][&#39;occupancy_schedule&#39;]       = initializer.occupancy_schedule
        self.mvbep_state[&#39;initializer&#39;][&#39;df_validation&#39;]            = initializer.df_validation
        self.mvbep_state[&#39;initializer&#39;][&#39;data_sufficiency&#39;]         = initializer.data_sufficiency
        self.mvbep_state[&#39;initializer&#39;][&#39;df_timestamps_highlights&#39;] = initializer.df_timestamps_highlights
         



    def generate_initialization_summary(self,
                                        file_name:str = None
    ):
        &#34;&#34;&#34; Generates summary of the initialization performed after `fit_training()`.

        The initialization summary is generated as an HTML file with highlights of the 
        initialization process including plots, descriptive data, and data sufficiency result.


        Parameters
        ----------
        file_name : str: (default None)
            Sets the name of the HTML initialization summary. In case no name was provided, 
            the resulting name will be `initiation_time` + `init_sum_`.

        Example
        ----------
        Writing the initialization summary of `mvbep_boulder` after running `fit_training()`.
        ```
        mvbep_boulder.generate_initialization_summary(file_name = &#39;mvbep_summaries/office-boulder_init-summary&#39;)
        ```

        &#34;&#34;&#34; 
        if self.mvbep_state[&#39;mvbep&#39;] == &#39;NOT INITIATED&#39;:
            print(&#39;The MVBEP object has not been initiated. Initiate the model using fit_training().&#39;)
            sys.exit()
        elif self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] == &#39;FAILED INITIATION&#39;:
            print(&#34;The MVBEP object failed the initiation process. Fix the data and run fit_training()&#34;)
            sys.exit()
        else: 
            GenerateInitializationSummary(file_name = file_name,
                df_input                    = self.mvbep_state[&#39;initializer&#39;][&#39;cleaned_data&#39;],
                frequency                   = self.mvbep_state[&#39;initializer&#39;][&#39;frequency&#39;],
                features                    = self.mvbep_state[&#39;initializer&#39;][&#39;features&#39;],
                df_timestamps_highlights    = self.mvbep_state[&#39;initializer&#39;][&#39;df_timestamps_highlights&#39;],
                df_validation               = self.mvbep_state[&#39;initializer&#39;][&#39;df_validation&#39;],
                data_sufficiency            = self.mvbep_state[&#39;initializer&#39;][&#39;data_sufficiency&#39;])





    def develop_mvbep(self,
                    modeling_methods:dict = None,
                    test_size:float = 0.2,
                    hyperparameter_tuning:bool = False,
                    ranking_method:str = &#39;min_cvrmse&#39;
    ):
        &#34;&#34;&#34; Transforms the cleaned data and develops regression models.

        Takes the cleaned data after `fit_training()` and iterates over the possible transformations
        while using each transformation to generate regression models using the chosen modeling approaches
        in `modeling_methods`. With each transformation, outputs such as evaluation metrics and models are 
        saved in the MVBEP object&#39;s state (i.e. attribute `mvbep_state`).

        Parameters
        ----------
        modeling_methods : dict:  (default None)
            The chosen modeling approaches to develop the baseline. In case None was passed, the argument is 
            passed by:
        ```python
        default_modeling_methods = {
            &#39;LR&#39; : True, # TOWT (If the frequency is hourly otherwise it is WLS)
            &#39;RF&#39; : True, # Random Regression Forest
            &#39;XGB&#39;: True, # Extreme Gradient Boosting
            &#39;SVR&#39;: True, # Support Vector Regressor
            &#39;SLP&#39;: True, # Feed Forward Neural Network
            &#39;KNN&#39;: True  # K-Nearest Neighbor
        }
        ```
        test_size : float: (default 0.2)
            Sets the testing set size out of the input data.
        hyperparameter_tuning : bool: (defalut False)
            
            - If True: the hyperparameter tuning process is performed for any model with hyperparameters to
            be tuned. 
            - If False: No hyperparameter tuning process is performed (except for KNN). 
        ranking_method : str: {&#39;min_cvrmse&#39;, &#39;min_nmbe&#39;} (default &#39;min_cvrmse&#39;)
            Sets the ranking method to choose the best model based on the testing set evaluation.

            - If &#39;min_cvrmse&#39;: The best model is selected based on Coefficient of Variation of Root Mean
            Squared Error (CV(RMSE))
            - If &#39;min_nmbe&#39;: The best model is selected based on Normalized Mean Bias Error (NMBE).


        Example
        ----------
        Developing `mvbep_boulder` after running `fit_training()` 
        ```
        mvbep_boulder.develop_mvbep()
        ```


        &#34;&#34;&#34; 
        # Checking initialization result 
        if self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] == &#39;NOT INITIATED&#39;:
            print(&#34;The MVBEP object didn&#39;t start the initiation process. Run fit_training()&#34;)
            sys.exit()
        elif self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] == &#39;FAILED INITIATION&#39;:
            print(&#34;The MVBEP object failed the initiation process. Fix the data and run fit_training()&#34;)
            sys.exit()
        elif self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] == &#39;DEVELOPED&#39;:
            print(&#34;The MVBEP started the initiation process and finished developing a MVBEP model. To predict baseline values run predict_energy_consumption()&#34;)
            sys.exit()

        # Updating the MVBEP object state
        self.mvbep_state[&#39;developer&#39;][&#39;training_inputs&#39;][&#39;test_size&#39;]               = test_size
        self.mvbep_state[&#39;developer&#39;][&#39;training_inputs&#39;][&#39;hyperparameter_tuning&#39;]   = hyperparameter_tuning
        self.mvbep_state[&#39;developer&#39;][&#39;training_inputs&#39;][&#39;ranking_method&#39;]          = ranking_method

        # Determine possible downsampling
        downsamplings = []
        training_frequency = []
        freq_features_dict = {&#39;15-min&#39;:None , &#39;hourly&#39;:None, &#39;daily&#39;:None, &#39;towt&#39;:None}
        if self.mvbep_state[&#39;initializer&#39;][&#39;frequency&#39;] == &#39;15-min&#39;:
            downsamplings = [None, &#39;15-min~hourly&#39;, &#39;15-min~daily&#39;]
            training_frequency = [&#39;15-min&#39;,&#39;hourly&#39;, &#39;daily&#39;]

        elif self.mvbep_state[&#39;initializer&#39;][&#39;frequency&#39;] == &#39;hourly&#39;:
            downsamplings = [None, &#39;hourly~daily&#39;]
            training_frequency = [&#39;hourly&#39;, &#39;daily&#39;]
        else: 
            downsamplings = [None]
            training_frequency = [&#39;daily&#39;]

        # MVBEP model development with different frequencies
        for downsample, freq  in zip(downsamplings, training_frequency): 
            #Transformation
            transformer = Transformer()
            transformer.fit(data                = self.mvbep_state[&#39;initializer&#39;][&#39;cleaned_data&#39;], 
                            timestamp_frequency = self.mvbep_state[&#39;initializer&#39;][&#39;frequency&#39;],
                            optional_features   = self.mvbep_state[&#39;initializer&#39;][&#39;features&#39;],
                            occupancy_schedule  = self.mvbep_state[&#39;initializer&#39;][&#39;occupancy_schedule&#39;],
                            country_code        = self.mvbep_state[&#39;initializer&#39;][&#39;country_code&#39;],
                            downsample_from_to  = downsample)
            transformer.transform()
            freq_features_dict[freq] = transformer.design_matrix_features
            if freq == &#39;hourly&#39;:
                freq_features_dict[&#39;towt&#39;] = transformer.towt_design_matrix_features

            #Training, hyperparameter tuning, and testing
            developer = Developer(modeling_methods      = modeling_methods,
                                test_size               = test_size,
                                hyperparameter_tuning   = hyperparameter_tuning,
                                ranking_method          = ranking_method)
            self.trans_df_cehck = transformer.df_fin
            self.feat_check = transformer.design_matrix_features
            developer.fit(data                      = transformer.df_fin,
                        timestamp_frequency         = freq,
                        towt_design_matrix          = transformer.towt_design_matrix,
                        design_matrix_features      = transformer.design_matrix_features,
                        towt_design_matrix_features = transformer.towt_design_matrix_features#,
                        #quarter=quarter
                        )
            
            
            #Saving MVBEP results
            self.mvbep_state[&#39;developer&#39;][&#39;training_inputs&#39;][&#39;self.modeling_methods&#39;]                     = developer.modeling_methods
            self.mvbep_state[&#39;developer&#39;][&#39;training_outputs&#39;][&#39;frequency&#39;][freq][&#39;models_dict&#39;]           = developer.models_dict
            self.mvbep_state[&#39;developer&#39;][&#39;training_outputs&#39;][&#39;frequency&#39;][freq][&#39;summary&#39;][&#39;evaluation&#39;] = developer.show_evaluation_metrics()
            print(&#39;Done with models dict&#39;)
            self.mvbep_state[&#39;developer&#39;][&#39;training_outputs&#39;][&#39;frequency&#39;][freq][&#39;summary&#39;][&#39;plot_data&#39;]  = developer.return_plot_data()
            print(&#39;Done with plotting&#39;)

        # Choosing the best model and best frequency
        # Summarizing outputs of each downsample iterations
        dfs_eval = []
        for freq, freq_dict in self.mvbep_state[&#39;developer&#39;][&#39;training_outputs&#39;][&#39;frequency&#39;].items():
            if freq_dict[&#39;models_dict&#39;] is not None:
               df_eval = freq_dict[&#39;summary&#39;][&#39;evaluation&#39;].loc[:, [&#39;train_cvrmse&#39;, &#39;train_nmbe&#39;, &#39;test_cvrmse&#39;, &#39;test_nmbe&#39;]].reset_index()
               df_eval[&#39;frequency&#39;] = freq
               dfs_eval.append(df_eval)
        training_summary = pd.concat(dfs_eval).reset_index(drop=True)

        #Saving development state
        self.mvbep_state[&#39;transformer&#39;][&#39;design_matrices_features&#39;] = freq_features_dict
        self.mvbep_state[&#39;developer&#39;][&#39;training_outputs&#39;][&#39;training_summary&#39;] = training_summary
        condition_col = &#39;test_cvrmse&#39; if ranking_method == &#39;min_cvrmse&#39; else &#39;test_nmbe&#39;
        self.mvbep_state[&#39;mvbep&#39;][&#39;best_model&#39;] = training_summary.sort_values(by=condition_col, key=abs).reset_index(drop=True)[&#39;models&#39;][0]
        self.mvbep_state[&#39;transformer&#39;][&#39;mvbep_frequency&#39;] = training_summary.sort_values(by=condition_col, key=abs).reset_index(drop=True)[&#39;frequency&#39;][0]
        self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] = &#39;DEVELOPED&#39;

    def generate_development_summary(self,
                                    file_name:str = None
    ):
        &#34;&#34;&#34; Generates development summary after using `develop_mvbep()`.

        Outputs an HTML file that summarizes the development process after running `develop_mvbep()`  

        Parameters
        ----------
        file_name : str: (default None)
            Sets the name of the HTML development summary. In case no name was provided, 
            the resulting name will be `initiation_time` + `dev_sum_`.

        Example
        ----------
        Writing the initialization summary of `mvbep_boulder` after running `develop_mvbep()`.
        ```
        mvbep_boulder.generate_development_summary(file_name = &#39;mvbep_summaries/office-boulder_dev-summary&#39;)
        ```


        &#34;&#34;&#34; 
        if self.mvbep_state[&#39;mvbep&#39;] != &#39;DEVELOPED&#39;:
            print(&#39;The MVBEP object has not been developed. Develop the model using develop_mvbep.&#39;)
            sys.exit()
        else:
            GenerateMVBEPSummary(file_name = file_name,
                                 mvbep_state = self.mvbep_state)

    def save_mvbep_state(self, file_name:str=None):
        &#34;&#34;&#34; Saves the current progress of the MVBEP object by storing `mvbep_state`.

        Parameters
        ----------
        file_name : str: (default None)
            Sets the name of the `Joblib` state file. In case no name was provided, 
            the resulting name will be `initiation_time` + `mvbep_state`.
            
        Example
        ----------
        Saving the state of either an initiated MVBEP by `fit_training()` or a developed one by `develop_mvbep()`.
        ```
        mvbep.save_state(&#39;mvbep_states/office-boulder_mvbep-state&#39;)
        ```


        &#34;&#34;&#34; 
        file_name = datetime.now().strftime(&#34;%Y%m%d-%H%M%S&#34;)+&#39;_mvbep_state&#39; if file_name is None else file_name
        with open(file_name, &#39;wb&#39;) as f:
            joblib.dump(self.mvbep_state, f, compress=5)

    def predict_energy_consumption(self,
                    data:pd.DataFrame,
                    generate_summary:bool = False,
                    file_name:str = None,
                    mismatch_date_threshold = 0.3,
                    total_missing = None,
                    max_consec_missing = None
        ):
        &#34;&#34;&#34; Generates savings quantification summary after using `develop_mvbep()`.

        Outputs an HTML file that summarizes the quantification process after running `develop_mvbep().`
        The quantification process requires post-retrofit data that matches the same frequency and features
        of the data used in initialization when running `fit_training()`. Features that was dropped in the
        initialization process are not required in the post-retrofit data. To see which features passed the 
        initialization process, check the output of `generate_initialization_summary()`.

        Parameters
        ----------
        data :pd.DataFrame 
            The post-retrofit data.
        generate_summary :bool: (default False)
            Either generates a summary in an HTML file or return a `list` of baseline energy consumption.
            In case the passed `data` does not meet the requirements, an initialization summary is generated
            regardless of the passed argument in `generate_summary`.

            - If True: A quantification summary is provided. The function does not return any object.
            - If False: A list of baseline energy consumption for the provided post-retrofit period is 
            returend.  
        file_name : str: (default None)
            Sets the name of the HTML quantification summary. In case no name was provided, 
            the resulting name will be `initiation_time` + `quant_sum_`.
        mismatch_date_threshold : float: (default = 0.3)
            Sets the threshold for values in `timestamp` column that cannot be converted from `str`
            to `datetime` object.  
        total_missing : int: (default `None`, The value is set based on frequency)
            Sets a threshold for the total number of a feature&#39;s missing observations to meet 
            data sufficiency requirements.
        max_consec_missing : int: (default `None`, The value is set based on frequency)
            Sets a threshold for consecutive missing observations in a single feature before
            the feature is dropped. 

        Example
        ----------
        Writing the quantification summary of `mvbep_boulder`.
        ```
        mvbep_boulder.predict_energy_consumption(data = df_boulder_post_retrofit,
                                                generate_summary = True,
                                                file_name=&#39;mvbep_summaries/office-boulder_dev-summary&#39;)
        ```


        &#34;&#34;&#34; 
        # Check MVBEP state
        if self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] != &#39;DEVELOPED&#39;:
            print(&#39;The MVBEP object has not been developed. Develop the model using develop_mvbep.&#39;)
            sys.exit()

        # Initialization 
        mismatch_date_threshold
        initializer = Initializer(mvbep_state = self.mvbep_state,
                                  mismatch_date_threshold = mismatch_date_threshold
                                 )
        initializer.validate_pred_data(data = data,
                                       total_missing = total_missing, 
                                       max_consec_missing = max_consec_missing
                                      )

        # Transformation
        if initializer.initializer_state != &#39;INITIATED&#39;:
            print(&#39;The post-retrofit data failed the initialization process. Check the initialization summary.&#39;)
            GenerateQuantificationSummary(mvbep_state               = self.mvbep_state, 
                                          df_init                   = initializer.df_fin,
                                          df_savings                = None,
                                          df_timestamps_highlights  = initializer.df_timestamps_highlights,
                                          df_validation             = initializer.df_validation,
                                          data_sufficiency          = initializer.data_sufficiency,
                                          file_name                 = file_name)
            sys.exit()

        transformer = Transformer()
        data_frequency = initializer.frequency 
        best_frequency = self.mvbep_state[&#39;transformer&#39;][&#39;mvbep_frequency&#39;]
        downsample = None if  best_frequency == data_frequency else data_frequency+&#39;~&#39;+best_frequency
        transformer.fit(data                = initializer.df_fin, 
                        timestamp_frequency = initializer.frequency,
                        optional_features   = initializer.features,
                        occupancy_schedule  = initializer.occupancy_schedule,
                        country_code        = initializer.country_code,
                        downsample_from_to  = downsample)
        transformer.transform()

        # Predictions 
        best_model = self.mvbep_state[&#39;mvbep&#39;][&#39;best_model&#39;]
        pred_pipeline = self.mvbep_state[&#39;developer&#39;][&#39;training_outputs&#39;][&#39;frequency&#39;][best_frequency][&#39;models_dict&#39;][best_model][&#39;model&#39;][&#39;pipe&#39;]
        if best_model == &#39;LR_towt&#39;:
            baseline_pred = pred_pipeline.predict(transformer.design_matrix_features)
        else: 
            baseline_pred = pred_pipeline.predict(transformer.df_fin.loc[:, transformer.design_matrix_features])
        
        # Savings
        df_savings = transformer.df_fin.copy()
        df_savings.rename(columns={&#39;energy&#39;:&#39;acut_post_energy&#39;}, inplace=True)
        df_savings[&#39;base_post_energy&#39;] = baseline_pred 

        # Interpretation
        if generate_summary:
            if not best_model.startswith(&#39;LR&#39;):
                _ , local_shap_values = return_interpretation_data(mvbep_state=self.mvbep_state,
                                                                global_sample_size=1,
                                                                local_sample_size=df_savings.shape[0],
                                                                df_input = df_savings,
                                                                design_matrix_features= transformer.design_matrix_features)
                df_savings = local_shap_values

        # return df_savings

        # Summary 
        if generate_summary:
            GenerateQuantificationSummary(mvbep_state               = self.mvbep_state, 
                                          df_init                   = initializer.df_fin,
                                          df_savings                = df_savings,
                                          df_timestamps_highlights  = initializer.df_timestamps_highlights,
                                          df_validation             = initializer.df_validation,
                                          data_sufficiency          = initializer.data_sufficiency,
                                          file_name                 = file_name)
        else:
            return baseline_pred</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="mvbep.MVBEP"><code class="flex name class">
<span>class <span class="ident">MVBEP</span></span>
<span>(</span><span>mvbep_state_path:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>MVBEP class to perform all steps of building an energy consumption baseline. </p>
<p>The class incorporates the 4 required modules for building a baseline starting
from initialization to savings quantification.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mvbep_state_path</code></strong> :&ensp;<code>str:
(Default value = None)</code></dt>
<dd>The file path for a saved MVBEP state in case the baseline creation process
stopped before the final step and saved by <code>save_mvbep_state()</code>.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>mvbep_state</code></strong> :&ensp;<code>dict:</code></dt>
<dd>A python object that saves all the required information for either continuing
the process of MVBEP or quantifying savings when the MVBEP object is developed.
<a href="??">Check MVBEP state structure</a></dd>
</dl>
<h2 id="example">Example</h2>
<p>In case a object of MVBEP was saved by using <code>save_mvbep_state</code> before, it can be loaded like</p>
<pre><code>mvbep_boulder = MVBEP(mvbep_state_path = 'mvbep_states/office-boulder_mvbep-state')
</code></pre>
<p>In case there was no object saved before, an instance of MVBEP is created by</p>
<pre><code>mvbep_boulder = MVBEP()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class MVBEP:
    &#34;&#34;&#34; MVBEP class to perform all steps of building an energy consumption baseline. 

        The class incorporates the 4 required modules for building a baseline starting 
        from initialization to savings quantification.

        Parameters
        ----------
        mvbep_state_path : str:  (Default value = None)  
            The file path for a saved MVBEP state in case the baseline creation process 
            stopped before the final step and saved by `save_mvbep_state()`.

        Attributes
        ----------
        mvbep_state : dict:  
            A python object that saves all the required information for either continuing
            the process of MVBEP or quantifying savings when the MVBEP object is developed. 
            [Check MVBEP state structure](??) 


        Example
        ----------
        In case a object of MVBEP was saved by using `save_mvbep_state` before, it can be loaded like
        ```
        mvbep_boulder = MVBEP(mvbep_state_path = &#39;mvbep_states/office-boulder_mvbep-state&#39;)
        ```

        In case there was no object saved before, an instance of MVBEP is created by
        ```
        mvbep_boulder = MVBEP()
        ```

    &#34;&#34;&#34;
    def __init__(self, mvbep_state_path:str=None):
        self.mvbep_state = {
            &#39;mvbep&#39;:{
                &#39;date&#39;             : str(datetime.now().strftime(&#34;%Y%m%d-%H%M%S&#34;)),
                &#39;version&#39;          : 1.0,
                &#39;best_model&#39;       : None,
                &#39;development_state&#39;: &#39;NOT INITIATED&#39;
            },
            
            &#39;initializer&#39;:{
                &#39;cleaned_data&#39;              : None,
                &#39;frequency&#39;                 : None,
                &#39;features&#39;                  : None,
                &#39;country_code&#39;              : None,
                &#39;df_validation&#39;             : None,
                &#39;data_sufficiency&#39;          : None,
                &#39;occupancy_schedule&#39;        : None,
                &#39;df_timestamps_highlights&#39;  : None
            },

            &#39;transformer&#39;:{
                &#39;mvbep_frequency&#39;               : None,
                &#39;design_matrices_features&#39;      : None
            },
            
            &#39;developer&#39;:{
                &#39;training_inputs&#39;:{
                    &#39;modeling_methods&#39;      : None,
                    &#39;test_size&#39;             : None,
                    &#39;hyperparameter_tuning&#39; : None,
                    &#39;ranking_method&#39;        : None
                },
                &#39;training_outputs&#39;:{
                    &#39;training_summary&#39;: None,
                    &#39;frequency&#39;:{
                        &#39;15-min&#39;:{
                            &#39;models_dict&#39; : None,
                            &#39;summary&#39;:{
                                &#39;evaluation&#39;: None, 
                                &#39;plot_data&#39; : None
                            }
                        },
                        &#39;hourly&#39;:{
                            &#39;models_dict&#39; : None,
                            &#39;summary&#39;:{
                                &#39;evaluation&#39;: None, 
                                &#39;plot_data&#39; : None
                            }
                        },
                        &#39;daily&#39;: {
                            &#39;models_dict&#39; : None,
                            &#39;summary&#39;:{
                                &#39;evaluation&#39;: None, 
                                &#39;plot_data&#39; : None
                            }
                        }
                    }
                }
            }
        }
        

        if mvbep_state_path is not None:  
            with open(mvbep_state_path, &#39;rb&#39;) as f:
                self.mvbep_state = joblib.load(f)
        else:
            pass


    def fit_training(self,
                    data:pd.DataFrame,
                    frequency:str,
                    country_code:str = None,
                    occupancy_schedule:dict = None,
                    mismatch_date_threshold:float = 0.3,
                    total_missing = None,
                    max_consec_missing = None, 
                    n_days = 360
    ): 
        &#34;&#34;&#34; Fits a MVBEP object with raw data. 

        This is the first method in developing an energy consumption baseline. The
        method takes required historical data to prepare them for next processes. 

        Parameters
        ----------
        data : pd.DataFrame:   
            A dataframe that includes the required data which includes at least 
            
            - Timestamps in 15-min or hourly intervals
            - Energy consumption
            - Outdoor dry-bulb temperature
        frequency : str: {&#39;15-min&#39;, &#39;hourly&#39;}
            The timestamps intervals frequency.
        country_code : str: (default `None`)
            A two-letter `str` indicating the country code in which the building resides.
            The supported codes are listed in holiday package [documentation](https://pypi.org/project/holidays/)
        occupancy_schedule : dict: (default `None`)
            A `dict` indicating the general occupancy density in the building. [Check
            the parameter structure ](??)
        mismatch_date_threshold : float: (default = 0.3)
            Sets the threshold for values in `timestamp` column that cannot be converted from `str`
            to `datetime` object.  
        total_missing : int: (default `None`, The value is set based on frequency)
            Sets a threshold for the total number of a feature&#39;s missing observations to meet 
            data sufficiency requirements.
        max_consec_missing : int: (default `None`, The value is set based on frequency)
            Sets a threshold for consecutive missing observations in a single feature before
            the feature is dropped.
        n_days : int: (default 365)
            Sets a threshold for the least number of days in `data`. 

        Example
        ----------
        Example of a building located in Boulder, CO, USA with hourly timestamps. The instance of MVBEP
        was created with a nmae of `mvbep_boulder`.
        ```
        mvbep_boulder.fit_training(
            data = df_boulder_office, 
            frequency = &#39;hourly&#39;,
            country_code = &#39;US&#39;
        )

        ```


        &#34;&#34;&#34;
        # Checking the MVBEP object state
        if self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] != &#39;NOT INITIATED&#39;:
            if self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] == &#39;DEVELOPED&#39;:
                print(&#34;The MVBEP started the initiation process and finished developing a MVBEP model. To predict baseline values run predict_energy_consumption()&#34;)
                sys.exit()
            else:
                print(&#34;The MVBEP started the initiation but didn&#39;t start developing a MVBEP model. To start development run develop_mvbep()&#34;)
                sys.exit()

        # Creating an initializer and validating the passed data
        initializer = Initializer(mismatch_date_threshold = mismatch_date_threshold)
        initializer.fit(data = data,
                        frequency = frequency,
                        country_code = country_code,
                        occupancy_schedule = occupancy_schedule
                        )
        initializer.validate(total_missing = total_missing, 
                            max_consec_missing = max_consec_missing,
                            n_days = n_days
                            )
        
        # Updating the MVBEP object state
        if initializer.data_sufficiency:
            self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;]  = &#39;INITIATED&#39;
        else: 
            self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;]  = &#39;FAILED INITIATION&#39;
        self.mvbep_state[&#39;initializer&#39;][&#39;cleaned_data&#39;]             = initializer.df_fin
        self.mvbep_state[&#39;initializer&#39;][&#39;frequency&#39;]                = initializer.frequency
        self.mvbep_state[&#39;initializer&#39;][&#39;features&#39;]                 = initializer.features
        self.mvbep_state[&#39;initializer&#39;][&#39;country_code&#39;]             = initializer.country_code
        self.mvbep_state[&#39;initializer&#39;][&#39;occupancy_schedule&#39;]       = initializer.occupancy_schedule
        self.mvbep_state[&#39;initializer&#39;][&#39;df_validation&#39;]            = initializer.df_validation
        self.mvbep_state[&#39;initializer&#39;][&#39;data_sufficiency&#39;]         = initializer.data_sufficiency
        self.mvbep_state[&#39;initializer&#39;][&#39;df_timestamps_highlights&#39;] = initializer.df_timestamps_highlights
         



    def generate_initialization_summary(self,
                                        file_name:str = None
    ):
        &#34;&#34;&#34; Generates summary of the initialization performed after `fit_training()`.

        The initialization summary is generated as an HTML file with highlights of the 
        initialization process including plots, descriptive data, and data sufficiency result.


        Parameters
        ----------
        file_name : str: (default None)
            Sets the name of the HTML initialization summary. In case no name was provided, 
            the resulting name will be `initiation_time` + `init_sum_`.

        Example
        ----------
        Writing the initialization summary of `mvbep_boulder` after running `fit_training()`.
        ```
        mvbep_boulder.generate_initialization_summary(file_name = &#39;mvbep_summaries/office-boulder_init-summary&#39;)
        ```

        &#34;&#34;&#34; 
        if self.mvbep_state[&#39;mvbep&#39;] == &#39;NOT INITIATED&#39;:
            print(&#39;The MVBEP object has not been initiated. Initiate the model using fit_training().&#39;)
            sys.exit()
        elif self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] == &#39;FAILED INITIATION&#39;:
            print(&#34;The MVBEP object failed the initiation process. Fix the data and run fit_training()&#34;)
            sys.exit()
        else: 
            GenerateInitializationSummary(file_name = file_name,
                df_input                    = self.mvbep_state[&#39;initializer&#39;][&#39;cleaned_data&#39;],
                frequency                   = self.mvbep_state[&#39;initializer&#39;][&#39;frequency&#39;],
                features                    = self.mvbep_state[&#39;initializer&#39;][&#39;features&#39;],
                df_timestamps_highlights    = self.mvbep_state[&#39;initializer&#39;][&#39;df_timestamps_highlights&#39;],
                df_validation               = self.mvbep_state[&#39;initializer&#39;][&#39;df_validation&#39;],
                data_sufficiency            = self.mvbep_state[&#39;initializer&#39;][&#39;data_sufficiency&#39;])





    def develop_mvbep(self,
                    modeling_methods:dict = None,
                    test_size:float = 0.2,
                    hyperparameter_tuning:bool = False,
                    ranking_method:str = &#39;min_cvrmse&#39;
    ):
        &#34;&#34;&#34; Transforms the cleaned data and develops regression models.

        Takes the cleaned data after `fit_training()` and iterates over the possible transformations
        while using each transformation to generate regression models using the chosen modeling approaches
        in `modeling_methods`. With each transformation, outputs such as evaluation metrics and models are 
        saved in the MVBEP object&#39;s state (i.e. attribute `mvbep_state`).

        Parameters
        ----------
        modeling_methods : dict:  (default None)
            The chosen modeling approaches to develop the baseline. In case None was passed, the argument is 
            passed by:
        ```python
        default_modeling_methods = {
            &#39;LR&#39; : True, # TOWT (If the frequency is hourly otherwise it is WLS)
            &#39;RF&#39; : True, # Random Regression Forest
            &#39;XGB&#39;: True, # Extreme Gradient Boosting
            &#39;SVR&#39;: True, # Support Vector Regressor
            &#39;SLP&#39;: True, # Feed Forward Neural Network
            &#39;KNN&#39;: True  # K-Nearest Neighbor
        }
        ```
        test_size : float: (default 0.2)
            Sets the testing set size out of the input data.
        hyperparameter_tuning : bool: (defalut False)
            
            - If True: the hyperparameter tuning process is performed for any model with hyperparameters to
            be tuned. 
            - If False: No hyperparameter tuning process is performed (except for KNN). 
        ranking_method : str: {&#39;min_cvrmse&#39;, &#39;min_nmbe&#39;} (default &#39;min_cvrmse&#39;)
            Sets the ranking method to choose the best model based on the testing set evaluation.

            - If &#39;min_cvrmse&#39;: The best model is selected based on Coefficient of Variation of Root Mean
            Squared Error (CV(RMSE))
            - If &#39;min_nmbe&#39;: The best model is selected based on Normalized Mean Bias Error (NMBE).


        Example
        ----------
        Developing `mvbep_boulder` after running `fit_training()` 
        ```
        mvbep_boulder.develop_mvbep()
        ```


        &#34;&#34;&#34; 
        # Checking initialization result 
        if self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] == &#39;NOT INITIATED&#39;:
            print(&#34;The MVBEP object didn&#39;t start the initiation process. Run fit_training()&#34;)
            sys.exit()
        elif self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] == &#39;FAILED INITIATION&#39;:
            print(&#34;The MVBEP object failed the initiation process. Fix the data and run fit_training()&#34;)
            sys.exit()
        elif self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] == &#39;DEVELOPED&#39;:
            print(&#34;The MVBEP started the initiation process and finished developing a MVBEP model. To predict baseline values run predict_energy_consumption()&#34;)
            sys.exit()

        # Updating the MVBEP object state
        self.mvbep_state[&#39;developer&#39;][&#39;training_inputs&#39;][&#39;test_size&#39;]               = test_size
        self.mvbep_state[&#39;developer&#39;][&#39;training_inputs&#39;][&#39;hyperparameter_tuning&#39;]   = hyperparameter_tuning
        self.mvbep_state[&#39;developer&#39;][&#39;training_inputs&#39;][&#39;ranking_method&#39;]          = ranking_method

        # Determine possible downsampling
        downsamplings = []
        training_frequency = []
        freq_features_dict = {&#39;15-min&#39;:None , &#39;hourly&#39;:None, &#39;daily&#39;:None, &#39;towt&#39;:None}
        if self.mvbep_state[&#39;initializer&#39;][&#39;frequency&#39;] == &#39;15-min&#39;:
            downsamplings = [None, &#39;15-min~hourly&#39;, &#39;15-min~daily&#39;]
            training_frequency = [&#39;15-min&#39;,&#39;hourly&#39;, &#39;daily&#39;]

        elif self.mvbep_state[&#39;initializer&#39;][&#39;frequency&#39;] == &#39;hourly&#39;:
            downsamplings = [None, &#39;hourly~daily&#39;]
            training_frequency = [&#39;hourly&#39;, &#39;daily&#39;]
        else: 
            downsamplings = [None]
            training_frequency = [&#39;daily&#39;]

        # MVBEP model development with different frequencies
        for downsample, freq  in zip(downsamplings, training_frequency): 
            #Transformation
            transformer = Transformer()
            transformer.fit(data                = self.mvbep_state[&#39;initializer&#39;][&#39;cleaned_data&#39;], 
                            timestamp_frequency = self.mvbep_state[&#39;initializer&#39;][&#39;frequency&#39;],
                            optional_features   = self.mvbep_state[&#39;initializer&#39;][&#39;features&#39;],
                            occupancy_schedule  = self.mvbep_state[&#39;initializer&#39;][&#39;occupancy_schedule&#39;],
                            country_code        = self.mvbep_state[&#39;initializer&#39;][&#39;country_code&#39;],
                            downsample_from_to  = downsample)
            transformer.transform()
            freq_features_dict[freq] = transformer.design_matrix_features
            if freq == &#39;hourly&#39;:
                freq_features_dict[&#39;towt&#39;] = transformer.towt_design_matrix_features

            #Training, hyperparameter tuning, and testing
            developer = Developer(modeling_methods      = modeling_methods,
                                test_size               = test_size,
                                hyperparameter_tuning   = hyperparameter_tuning,
                                ranking_method          = ranking_method)
            self.trans_df_cehck = transformer.df_fin
            self.feat_check = transformer.design_matrix_features
            developer.fit(data                      = transformer.df_fin,
                        timestamp_frequency         = freq,
                        towt_design_matrix          = transformer.towt_design_matrix,
                        design_matrix_features      = transformer.design_matrix_features,
                        towt_design_matrix_features = transformer.towt_design_matrix_features#,
                        #quarter=quarter
                        )
            
            
            #Saving MVBEP results
            self.mvbep_state[&#39;developer&#39;][&#39;training_inputs&#39;][&#39;self.modeling_methods&#39;]                     = developer.modeling_methods
            self.mvbep_state[&#39;developer&#39;][&#39;training_outputs&#39;][&#39;frequency&#39;][freq][&#39;models_dict&#39;]           = developer.models_dict
            self.mvbep_state[&#39;developer&#39;][&#39;training_outputs&#39;][&#39;frequency&#39;][freq][&#39;summary&#39;][&#39;evaluation&#39;] = developer.show_evaluation_metrics()
            print(&#39;Done with models dict&#39;)
            self.mvbep_state[&#39;developer&#39;][&#39;training_outputs&#39;][&#39;frequency&#39;][freq][&#39;summary&#39;][&#39;plot_data&#39;]  = developer.return_plot_data()
            print(&#39;Done with plotting&#39;)

        # Choosing the best model and best frequency
        # Summarizing outputs of each downsample iterations
        dfs_eval = []
        for freq, freq_dict in self.mvbep_state[&#39;developer&#39;][&#39;training_outputs&#39;][&#39;frequency&#39;].items():
            if freq_dict[&#39;models_dict&#39;] is not None:
               df_eval = freq_dict[&#39;summary&#39;][&#39;evaluation&#39;].loc[:, [&#39;train_cvrmse&#39;, &#39;train_nmbe&#39;, &#39;test_cvrmse&#39;, &#39;test_nmbe&#39;]].reset_index()
               df_eval[&#39;frequency&#39;] = freq
               dfs_eval.append(df_eval)
        training_summary = pd.concat(dfs_eval).reset_index(drop=True)

        #Saving development state
        self.mvbep_state[&#39;transformer&#39;][&#39;design_matrices_features&#39;] = freq_features_dict
        self.mvbep_state[&#39;developer&#39;][&#39;training_outputs&#39;][&#39;training_summary&#39;] = training_summary
        condition_col = &#39;test_cvrmse&#39; if ranking_method == &#39;min_cvrmse&#39; else &#39;test_nmbe&#39;
        self.mvbep_state[&#39;mvbep&#39;][&#39;best_model&#39;] = training_summary.sort_values(by=condition_col, key=abs).reset_index(drop=True)[&#39;models&#39;][0]
        self.mvbep_state[&#39;transformer&#39;][&#39;mvbep_frequency&#39;] = training_summary.sort_values(by=condition_col, key=abs).reset_index(drop=True)[&#39;frequency&#39;][0]
        self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] = &#39;DEVELOPED&#39;

    def generate_development_summary(self,
                                    file_name:str = None
    ):
        &#34;&#34;&#34; Generates development summary after using `develop_mvbep()`.

        Outputs an HTML file that summarizes the development process after running `develop_mvbep()`  

        Parameters
        ----------
        file_name : str: (default None)
            Sets the name of the HTML development summary. In case no name was provided, 
            the resulting name will be `initiation_time` + `dev_sum_`.

        Example
        ----------
        Writing the initialization summary of `mvbep_boulder` after running `develop_mvbep()`.
        ```
        mvbep_boulder.generate_development_summary(file_name = &#39;mvbep_summaries/office-boulder_dev-summary&#39;)
        ```


        &#34;&#34;&#34; 
        if self.mvbep_state[&#39;mvbep&#39;] != &#39;DEVELOPED&#39;:
            print(&#39;The MVBEP object has not been developed. Develop the model using develop_mvbep.&#39;)
            sys.exit()
        else:
            GenerateMVBEPSummary(file_name = file_name,
                                 mvbep_state = self.mvbep_state)

    def save_mvbep_state(self, file_name:str=None):
        &#34;&#34;&#34; Saves the current progress of the MVBEP object by storing `mvbep_state`.

        Parameters
        ----------
        file_name : str: (default None)
            Sets the name of the `Joblib` state file. In case no name was provided, 
            the resulting name will be `initiation_time` + `mvbep_state`.
            
        Example
        ----------
        Saving the state of either an initiated MVBEP by `fit_training()` or a developed one by `develop_mvbep()`.
        ```
        mvbep.save_state(&#39;mvbep_states/office-boulder_mvbep-state&#39;)
        ```


        &#34;&#34;&#34; 
        file_name = datetime.now().strftime(&#34;%Y%m%d-%H%M%S&#34;)+&#39;_mvbep_state&#39; if file_name is None else file_name
        with open(file_name, &#39;wb&#39;) as f:
            joblib.dump(self.mvbep_state, f, compress=5)

    def predict_energy_consumption(self,
                    data:pd.DataFrame,
                    generate_summary:bool = False,
                    file_name:str = None,
                    mismatch_date_threshold = 0.3,
                    total_missing = None,
                    max_consec_missing = None
        ):
        &#34;&#34;&#34; Generates savings quantification summary after using `develop_mvbep()`.

        Outputs an HTML file that summarizes the quantification process after running `develop_mvbep().`
        The quantification process requires post-retrofit data that matches the same frequency and features
        of the data used in initialization when running `fit_training()`. Features that was dropped in the
        initialization process are not required in the post-retrofit data. To see which features passed the 
        initialization process, check the output of `generate_initialization_summary()`.

        Parameters
        ----------
        data :pd.DataFrame 
            The post-retrofit data.
        generate_summary :bool: (default False)
            Either generates a summary in an HTML file or return a `list` of baseline energy consumption.
            In case the passed `data` does not meet the requirements, an initialization summary is generated
            regardless of the passed argument in `generate_summary`.

            - If True: A quantification summary is provided. The function does not return any object.
            - If False: A list of baseline energy consumption for the provided post-retrofit period is 
            returend.  
        file_name : str: (default None)
            Sets the name of the HTML quantification summary. In case no name was provided, 
            the resulting name will be `initiation_time` + `quant_sum_`.
        mismatch_date_threshold : float: (default = 0.3)
            Sets the threshold for values in `timestamp` column that cannot be converted from `str`
            to `datetime` object.  
        total_missing : int: (default `None`, The value is set based on frequency)
            Sets a threshold for the total number of a feature&#39;s missing observations to meet 
            data sufficiency requirements.
        max_consec_missing : int: (default `None`, The value is set based on frequency)
            Sets a threshold for consecutive missing observations in a single feature before
            the feature is dropped. 

        Example
        ----------
        Writing the quantification summary of `mvbep_boulder`.
        ```
        mvbep_boulder.predict_energy_consumption(data = df_boulder_post_retrofit,
                                                generate_summary = True,
                                                file_name=&#39;mvbep_summaries/office-boulder_dev-summary&#39;)
        ```


        &#34;&#34;&#34; 
        # Check MVBEP state
        if self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] != &#39;DEVELOPED&#39;:
            print(&#39;The MVBEP object has not been developed. Develop the model using develop_mvbep.&#39;)
            sys.exit()

        # Initialization 
        mismatch_date_threshold
        initializer = Initializer(mvbep_state = self.mvbep_state,
                                  mismatch_date_threshold = mismatch_date_threshold
                                 )
        initializer.validate_pred_data(data = data,
                                       total_missing = total_missing, 
                                       max_consec_missing = max_consec_missing
                                      )

        # Transformation
        if initializer.initializer_state != &#39;INITIATED&#39;:
            print(&#39;The post-retrofit data failed the initialization process. Check the initialization summary.&#39;)
            GenerateQuantificationSummary(mvbep_state               = self.mvbep_state, 
                                          df_init                   = initializer.df_fin,
                                          df_savings                = None,
                                          df_timestamps_highlights  = initializer.df_timestamps_highlights,
                                          df_validation             = initializer.df_validation,
                                          data_sufficiency          = initializer.data_sufficiency,
                                          file_name                 = file_name)
            sys.exit()

        transformer = Transformer()
        data_frequency = initializer.frequency 
        best_frequency = self.mvbep_state[&#39;transformer&#39;][&#39;mvbep_frequency&#39;]
        downsample = None if  best_frequency == data_frequency else data_frequency+&#39;~&#39;+best_frequency
        transformer.fit(data                = initializer.df_fin, 
                        timestamp_frequency = initializer.frequency,
                        optional_features   = initializer.features,
                        occupancy_schedule  = initializer.occupancy_schedule,
                        country_code        = initializer.country_code,
                        downsample_from_to  = downsample)
        transformer.transform()

        # Predictions 
        best_model = self.mvbep_state[&#39;mvbep&#39;][&#39;best_model&#39;]
        pred_pipeline = self.mvbep_state[&#39;developer&#39;][&#39;training_outputs&#39;][&#39;frequency&#39;][best_frequency][&#39;models_dict&#39;][best_model][&#39;model&#39;][&#39;pipe&#39;]
        if best_model == &#39;LR_towt&#39;:
            baseline_pred = pred_pipeline.predict(transformer.design_matrix_features)
        else: 
            baseline_pred = pred_pipeline.predict(transformer.df_fin.loc[:, transformer.design_matrix_features])
        
        # Savings
        df_savings = transformer.df_fin.copy()
        df_savings.rename(columns={&#39;energy&#39;:&#39;acut_post_energy&#39;}, inplace=True)
        df_savings[&#39;base_post_energy&#39;] = baseline_pred 

        # Interpretation
        if generate_summary:
            if not best_model.startswith(&#39;LR&#39;):
                _ , local_shap_values = return_interpretation_data(mvbep_state=self.mvbep_state,
                                                                global_sample_size=1,
                                                                local_sample_size=df_savings.shape[0],
                                                                df_input = df_savings,
                                                                design_matrix_features= transformer.design_matrix_features)
                df_savings = local_shap_values

        # return df_savings

        # Summary 
        if generate_summary:
            GenerateQuantificationSummary(mvbep_state               = self.mvbep_state, 
                                          df_init                   = initializer.df_fin,
                                          df_savings                = df_savings,
                                          df_timestamps_highlights  = initializer.df_timestamps_highlights,
                                          df_validation             = initializer.df_validation,
                                          data_sufficiency          = initializer.data_sufficiency,
                                          file_name                 = file_name)
        else:
            return baseline_pred</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="mvbep.MVBEP.develop_mvbep"><code class="name flex">
<span>def <span class="ident">develop_mvbep</span></span>(<span>self, modeling_methods:Â dictÂ =Â None, test_size:Â floatÂ =Â 0.2, hyperparameter_tuning:Â boolÂ =Â False, ranking_method:Â strÂ =Â 'min_cvrmse')</span>
</code></dt>
<dd>
<div class="desc"><p>Transforms the cleaned data and develops regression models.</p>
<p>Takes the cleaned data after <code>fit_training()</code> and iterates over the possible transformations
while using each transformation to generate regression models using the chosen modeling approaches
in <code>modeling_methods</code>. With each transformation, outputs such as evaluation metrics and models are
saved in the MVBEP object's state (i.e. attribute <code>mvbep_state</code>).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>modeling_methods</code></strong> :&ensp;<code>dict:
(default None)</code></dt>
<dd>The chosen modeling approaches to develop the baseline. In case None was passed, the argument is
passed by:</dd>
</dl>
<pre><code class="language-python">default_modeling_methods = {
    'LR' : True, # TOWT (If the frequency is hourly otherwise it is WLS)
    'RF' : True, # Random Regression Forest
    'XGB': True, # Extreme Gradient Boosting
    'SVR': True, # Support Vector Regressor
    'SLP': True, # Feed Forward Neural Network
    'KNN': True  # K-Nearest Neighbor
}
</code></pre>
<dl>
<dt><strong><code>test_size</code></strong> :&ensp;<code>float: (default 0.2)</code></dt>
<dd>Sets the testing set size out of the input data.</dd>
<dt><strong><code>hyperparameter_tuning</code></strong> :&ensp;<code>bool: (defalut False)</code></dt>
<dd>
<ul>
<li>If True: the hyperparameter tuning process is performed for any model with hyperparameters to
be tuned. </li>
<li>If False: No hyperparameter tuning process is performed (except for KNN).</li>
</ul>
</dd>
<dt><strong><code>ranking_method</code></strong> :&ensp;<code>str: {'min_cvrmse', 'min_nmbe'} (default 'min_cvrmse')</code></dt>
<dd>
<p>Sets the ranking method to choose the best model based on the testing set evaluation.</p>
<ul>
<li>If 'min_cvrmse': The best model is selected based on Coefficient of Variation of Root Mean
Squared Error (CV(RMSE))</li>
<li>If 'min_nmbe': The best model is selected based on Normalized Mean Bias Error (NMBE).</li>
</ul>
</dd>
</dl>
<h2 id="example">Example</h2>
<p>Developing <code>mvbep_boulder</code> after running <code>fit_training()</code> </p>
<pre><code>mvbep_boulder.develop_mvbep()
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def develop_mvbep(self,
                modeling_methods:dict = None,
                test_size:float = 0.2,
                hyperparameter_tuning:bool = False,
                ranking_method:str = &#39;min_cvrmse&#39;
):
    &#34;&#34;&#34; Transforms the cleaned data and develops regression models.

    Takes the cleaned data after `fit_training()` and iterates over the possible transformations
    while using each transformation to generate regression models using the chosen modeling approaches
    in `modeling_methods`. With each transformation, outputs such as evaluation metrics and models are 
    saved in the MVBEP object&#39;s state (i.e. attribute `mvbep_state`).

    Parameters
    ----------
    modeling_methods : dict:  (default None)
        The chosen modeling approaches to develop the baseline. In case None was passed, the argument is 
        passed by:
    ```python
    default_modeling_methods = {
        &#39;LR&#39; : True, # TOWT (If the frequency is hourly otherwise it is WLS)
        &#39;RF&#39; : True, # Random Regression Forest
        &#39;XGB&#39;: True, # Extreme Gradient Boosting
        &#39;SVR&#39;: True, # Support Vector Regressor
        &#39;SLP&#39;: True, # Feed Forward Neural Network
        &#39;KNN&#39;: True  # K-Nearest Neighbor
    }
    ```
    test_size : float: (default 0.2)
        Sets the testing set size out of the input data.
    hyperparameter_tuning : bool: (defalut False)
        
        - If True: the hyperparameter tuning process is performed for any model with hyperparameters to
        be tuned. 
        - If False: No hyperparameter tuning process is performed (except for KNN). 
    ranking_method : str: {&#39;min_cvrmse&#39;, &#39;min_nmbe&#39;} (default &#39;min_cvrmse&#39;)
        Sets the ranking method to choose the best model based on the testing set evaluation.

        - If &#39;min_cvrmse&#39;: The best model is selected based on Coefficient of Variation of Root Mean
        Squared Error (CV(RMSE))
        - If &#39;min_nmbe&#39;: The best model is selected based on Normalized Mean Bias Error (NMBE).


    Example
    ----------
    Developing `mvbep_boulder` after running `fit_training()` 
    ```
    mvbep_boulder.develop_mvbep()
    ```


    &#34;&#34;&#34; 
    # Checking initialization result 
    if self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] == &#39;NOT INITIATED&#39;:
        print(&#34;The MVBEP object didn&#39;t start the initiation process. Run fit_training()&#34;)
        sys.exit()
    elif self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] == &#39;FAILED INITIATION&#39;:
        print(&#34;The MVBEP object failed the initiation process. Fix the data and run fit_training()&#34;)
        sys.exit()
    elif self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] == &#39;DEVELOPED&#39;:
        print(&#34;The MVBEP started the initiation process and finished developing a MVBEP model. To predict baseline values run predict_energy_consumption()&#34;)
        sys.exit()

    # Updating the MVBEP object state
    self.mvbep_state[&#39;developer&#39;][&#39;training_inputs&#39;][&#39;test_size&#39;]               = test_size
    self.mvbep_state[&#39;developer&#39;][&#39;training_inputs&#39;][&#39;hyperparameter_tuning&#39;]   = hyperparameter_tuning
    self.mvbep_state[&#39;developer&#39;][&#39;training_inputs&#39;][&#39;ranking_method&#39;]          = ranking_method

    # Determine possible downsampling
    downsamplings = []
    training_frequency = []
    freq_features_dict = {&#39;15-min&#39;:None , &#39;hourly&#39;:None, &#39;daily&#39;:None, &#39;towt&#39;:None}
    if self.mvbep_state[&#39;initializer&#39;][&#39;frequency&#39;] == &#39;15-min&#39;:
        downsamplings = [None, &#39;15-min~hourly&#39;, &#39;15-min~daily&#39;]
        training_frequency = [&#39;15-min&#39;,&#39;hourly&#39;, &#39;daily&#39;]

    elif self.mvbep_state[&#39;initializer&#39;][&#39;frequency&#39;] == &#39;hourly&#39;:
        downsamplings = [None, &#39;hourly~daily&#39;]
        training_frequency = [&#39;hourly&#39;, &#39;daily&#39;]
    else: 
        downsamplings = [None]
        training_frequency = [&#39;daily&#39;]

    # MVBEP model development with different frequencies
    for downsample, freq  in zip(downsamplings, training_frequency): 
        #Transformation
        transformer = Transformer()
        transformer.fit(data                = self.mvbep_state[&#39;initializer&#39;][&#39;cleaned_data&#39;], 
                        timestamp_frequency = self.mvbep_state[&#39;initializer&#39;][&#39;frequency&#39;],
                        optional_features   = self.mvbep_state[&#39;initializer&#39;][&#39;features&#39;],
                        occupancy_schedule  = self.mvbep_state[&#39;initializer&#39;][&#39;occupancy_schedule&#39;],
                        country_code        = self.mvbep_state[&#39;initializer&#39;][&#39;country_code&#39;],
                        downsample_from_to  = downsample)
        transformer.transform()
        freq_features_dict[freq] = transformer.design_matrix_features
        if freq == &#39;hourly&#39;:
            freq_features_dict[&#39;towt&#39;] = transformer.towt_design_matrix_features

        #Training, hyperparameter tuning, and testing
        developer = Developer(modeling_methods      = modeling_methods,
                            test_size               = test_size,
                            hyperparameter_tuning   = hyperparameter_tuning,
                            ranking_method          = ranking_method)
        self.trans_df_cehck = transformer.df_fin
        self.feat_check = transformer.design_matrix_features
        developer.fit(data                      = transformer.df_fin,
                    timestamp_frequency         = freq,
                    towt_design_matrix          = transformer.towt_design_matrix,
                    design_matrix_features      = transformer.design_matrix_features,
                    towt_design_matrix_features = transformer.towt_design_matrix_features#,
                    #quarter=quarter
                    )
        
        
        #Saving MVBEP results
        self.mvbep_state[&#39;developer&#39;][&#39;training_inputs&#39;][&#39;self.modeling_methods&#39;]                     = developer.modeling_methods
        self.mvbep_state[&#39;developer&#39;][&#39;training_outputs&#39;][&#39;frequency&#39;][freq][&#39;models_dict&#39;]           = developer.models_dict
        self.mvbep_state[&#39;developer&#39;][&#39;training_outputs&#39;][&#39;frequency&#39;][freq][&#39;summary&#39;][&#39;evaluation&#39;] = developer.show_evaluation_metrics()
        print(&#39;Done with models dict&#39;)
        self.mvbep_state[&#39;developer&#39;][&#39;training_outputs&#39;][&#39;frequency&#39;][freq][&#39;summary&#39;][&#39;plot_data&#39;]  = developer.return_plot_data()
        print(&#39;Done with plotting&#39;)

    # Choosing the best model and best frequency
    # Summarizing outputs of each downsample iterations
    dfs_eval = []
    for freq, freq_dict in self.mvbep_state[&#39;developer&#39;][&#39;training_outputs&#39;][&#39;frequency&#39;].items():
        if freq_dict[&#39;models_dict&#39;] is not None:
           df_eval = freq_dict[&#39;summary&#39;][&#39;evaluation&#39;].loc[:, [&#39;train_cvrmse&#39;, &#39;train_nmbe&#39;, &#39;test_cvrmse&#39;, &#39;test_nmbe&#39;]].reset_index()
           df_eval[&#39;frequency&#39;] = freq
           dfs_eval.append(df_eval)
    training_summary = pd.concat(dfs_eval).reset_index(drop=True)

    #Saving development state
    self.mvbep_state[&#39;transformer&#39;][&#39;design_matrices_features&#39;] = freq_features_dict
    self.mvbep_state[&#39;developer&#39;][&#39;training_outputs&#39;][&#39;training_summary&#39;] = training_summary
    condition_col = &#39;test_cvrmse&#39; if ranking_method == &#39;min_cvrmse&#39; else &#39;test_nmbe&#39;
    self.mvbep_state[&#39;mvbep&#39;][&#39;best_model&#39;] = training_summary.sort_values(by=condition_col, key=abs).reset_index(drop=True)[&#39;models&#39;][0]
    self.mvbep_state[&#39;transformer&#39;][&#39;mvbep_frequency&#39;] = training_summary.sort_values(by=condition_col, key=abs).reset_index(drop=True)[&#39;frequency&#39;][0]
    self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] = &#39;DEVELOPED&#39;</code></pre>
</details>
</dd>
<dt id="mvbep.MVBEP.fit_training"><code class="name flex">
<span>def <span class="ident">fit_training</span></span>(<span>self, data:Â pandas.core.frame.DataFrame, frequency:Â str, country_code:Â strÂ =Â None, occupancy_schedule:Â dictÂ =Â None, mismatch_date_threshold:Â floatÂ =Â 0.3, total_missing=None, max_consec_missing=None, n_days=360)</span>
</code></dt>
<dd>
<div class="desc"><p>Fits a MVBEP object with raw data. </p>
<p>This is the first method in developing an energy consumption baseline. The
method takes required historical data to prepare them for next processes. </p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>pd.DataFrame:</code></dt>
<dd>
<p>A dataframe that includes the required data which includes at least </p>
<ul>
<li>Timestamps in 15-min or hourly intervals</li>
<li>Energy consumption</li>
<li>Outdoor dry-bulb temperature</li>
</ul>
</dd>
<dt><strong><code>frequency</code></strong> :&ensp;<code>str: {'15-min', 'hourly'}</code></dt>
<dd>The timestamps intervals frequency.</dd>
<dt><strong><code>country_code</code></strong> :&ensp;<code>str: (default</code>None<code>)</code></dt>
<dd>A two-letter <code>str</code> indicating the country code in which the building resides.
The supported codes are listed in holiday package <a href="https://pypi.org/project/holidays/">documentation</a></dd>
<dt><strong><code>occupancy_schedule</code></strong> :&ensp;<code>dict: (default</code>None<code>)</code></dt>
<dd>A <code>dict</code> indicating the general occupancy density in the building. <a href="??">Check
the parameter structure </a></dd>
<dt><strong><code>mismatch_date_threshold</code></strong> :&ensp;<code>float: (default = 0.3)</code></dt>
<dd>Sets the threshold for values in <code>timestamp</code> column that cannot be converted from <code>str</code>
to <code>datetime</code> object.</dd>
<dt><strong><code>total_missing</code></strong> :&ensp;<code>int: (default</code>None<code>, The value is set based on frequency)</code></dt>
<dd>Sets a threshold for the total number of a feature's missing observations to meet
data sufficiency requirements.</dd>
<dt><strong><code>max_consec_missing</code></strong> :&ensp;<code>int: (default</code>None<code>, The value is set based on frequency)</code></dt>
<dd>Sets a threshold for consecutive missing observations in a single feature before
the feature is dropped.</dd>
<dt><strong><code>n_days</code></strong> :&ensp;<code>int: (default 365)</code></dt>
<dd>Sets a threshold for the least number of days in <code>data</code>.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Example of a building located in Boulder, CO, USA with hourly timestamps. The instance of MVBEP
was created with a nmae of <code>mvbep_boulder</code>.</p>
<pre><code>mvbep_boulder.fit_training(
    data = df_boulder_office, 
    frequency = 'hourly',
    country_code = 'US'
)

</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fit_training(self,
                data:pd.DataFrame,
                frequency:str,
                country_code:str = None,
                occupancy_schedule:dict = None,
                mismatch_date_threshold:float = 0.3,
                total_missing = None,
                max_consec_missing = None, 
                n_days = 360
): 
    &#34;&#34;&#34; Fits a MVBEP object with raw data. 

    This is the first method in developing an energy consumption baseline. The
    method takes required historical data to prepare them for next processes. 

    Parameters
    ----------
    data : pd.DataFrame:   
        A dataframe that includes the required data which includes at least 
        
        - Timestamps in 15-min or hourly intervals
        - Energy consumption
        - Outdoor dry-bulb temperature
    frequency : str: {&#39;15-min&#39;, &#39;hourly&#39;}
        The timestamps intervals frequency.
    country_code : str: (default `None`)
        A two-letter `str` indicating the country code in which the building resides.
        The supported codes are listed in holiday package [documentation](https://pypi.org/project/holidays/)
    occupancy_schedule : dict: (default `None`)
        A `dict` indicating the general occupancy density in the building. [Check
        the parameter structure ](??)
    mismatch_date_threshold : float: (default = 0.3)
        Sets the threshold for values in `timestamp` column that cannot be converted from `str`
        to `datetime` object.  
    total_missing : int: (default `None`, The value is set based on frequency)
        Sets a threshold for the total number of a feature&#39;s missing observations to meet 
        data sufficiency requirements.
    max_consec_missing : int: (default `None`, The value is set based on frequency)
        Sets a threshold for consecutive missing observations in a single feature before
        the feature is dropped.
    n_days : int: (default 365)
        Sets a threshold for the least number of days in `data`. 

    Example
    ----------
    Example of a building located in Boulder, CO, USA with hourly timestamps. The instance of MVBEP
    was created with a nmae of `mvbep_boulder`.
    ```
    mvbep_boulder.fit_training(
        data = df_boulder_office, 
        frequency = &#39;hourly&#39;,
        country_code = &#39;US&#39;
    )

    ```


    &#34;&#34;&#34;
    # Checking the MVBEP object state
    if self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] != &#39;NOT INITIATED&#39;:
        if self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] == &#39;DEVELOPED&#39;:
            print(&#34;The MVBEP started the initiation process and finished developing a MVBEP model. To predict baseline values run predict_energy_consumption()&#34;)
            sys.exit()
        else:
            print(&#34;The MVBEP started the initiation but didn&#39;t start developing a MVBEP model. To start development run develop_mvbep()&#34;)
            sys.exit()

    # Creating an initializer and validating the passed data
    initializer = Initializer(mismatch_date_threshold = mismatch_date_threshold)
    initializer.fit(data = data,
                    frequency = frequency,
                    country_code = country_code,
                    occupancy_schedule = occupancy_schedule
                    )
    initializer.validate(total_missing = total_missing, 
                        max_consec_missing = max_consec_missing,
                        n_days = n_days
                        )
    
    # Updating the MVBEP object state
    if initializer.data_sufficiency:
        self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;]  = &#39;INITIATED&#39;
    else: 
        self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;]  = &#39;FAILED INITIATION&#39;
    self.mvbep_state[&#39;initializer&#39;][&#39;cleaned_data&#39;]             = initializer.df_fin
    self.mvbep_state[&#39;initializer&#39;][&#39;frequency&#39;]                = initializer.frequency
    self.mvbep_state[&#39;initializer&#39;][&#39;features&#39;]                 = initializer.features
    self.mvbep_state[&#39;initializer&#39;][&#39;country_code&#39;]             = initializer.country_code
    self.mvbep_state[&#39;initializer&#39;][&#39;occupancy_schedule&#39;]       = initializer.occupancy_schedule
    self.mvbep_state[&#39;initializer&#39;][&#39;df_validation&#39;]            = initializer.df_validation
    self.mvbep_state[&#39;initializer&#39;][&#39;data_sufficiency&#39;]         = initializer.data_sufficiency
    self.mvbep_state[&#39;initializer&#39;][&#39;df_timestamps_highlights&#39;] = initializer.df_timestamps_highlights</code></pre>
</details>
</dd>
<dt id="mvbep.MVBEP.generate_development_summary"><code class="name flex">
<span>def <span class="ident">generate_development_summary</span></span>(<span>self, file_name:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates development summary after using <code>develop_mvbep()</code>.</p>
<p>Outputs an HTML file that summarizes the development process after running <code>develop_mvbep()</code>
</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str: (default None)</code></dt>
<dd>Sets the name of the HTML development summary. In case no name was provided,
the resulting name will be <code>initiation_time</code> + <code>dev_sum_</code>.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Writing the initialization summary of <code>mvbep_boulder</code> after running <code>develop_mvbep()</code>.</p>
<pre><code>mvbep_boulder.generate_development_summary(file_name = 'mvbep_summaries/office-boulder_dev-summary')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_development_summary(self,
                                file_name:str = None
):
    &#34;&#34;&#34; Generates development summary after using `develop_mvbep()`.

    Outputs an HTML file that summarizes the development process after running `develop_mvbep()`  

    Parameters
    ----------
    file_name : str: (default None)
        Sets the name of the HTML development summary. In case no name was provided, 
        the resulting name will be `initiation_time` + `dev_sum_`.

    Example
    ----------
    Writing the initialization summary of `mvbep_boulder` after running `develop_mvbep()`.
    ```
    mvbep_boulder.generate_development_summary(file_name = &#39;mvbep_summaries/office-boulder_dev-summary&#39;)
    ```


    &#34;&#34;&#34; 
    if self.mvbep_state[&#39;mvbep&#39;] != &#39;DEVELOPED&#39;:
        print(&#39;The MVBEP object has not been developed. Develop the model using develop_mvbep.&#39;)
        sys.exit()
    else:
        GenerateMVBEPSummary(file_name = file_name,
                             mvbep_state = self.mvbep_state)</code></pre>
</details>
</dd>
<dt id="mvbep.MVBEP.generate_initialization_summary"><code class="name flex">
<span>def <span class="ident">generate_initialization_summary</span></span>(<span>self, file_name:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates summary of the initialization performed after <code>fit_training()</code>.</p>
<p>The initialization summary is generated as an HTML file with highlights of the
initialization process including plots, descriptive data, and data sufficiency result.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str: (default None)</code></dt>
<dd>Sets the name of the HTML initialization summary. In case no name was provided,
the resulting name will be <code>initiation_time</code> + <code>init_sum_</code>.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Writing the initialization summary of <code>mvbep_boulder</code> after running <code>fit_training()</code>.</p>
<pre><code>mvbep_boulder.generate_initialization_summary(file_name = 'mvbep_summaries/office-boulder_init-summary')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_initialization_summary(self,
                                    file_name:str = None
):
    &#34;&#34;&#34; Generates summary of the initialization performed after `fit_training()`.

    The initialization summary is generated as an HTML file with highlights of the 
    initialization process including plots, descriptive data, and data sufficiency result.


    Parameters
    ----------
    file_name : str: (default None)
        Sets the name of the HTML initialization summary. In case no name was provided, 
        the resulting name will be `initiation_time` + `init_sum_`.

    Example
    ----------
    Writing the initialization summary of `mvbep_boulder` after running `fit_training()`.
    ```
    mvbep_boulder.generate_initialization_summary(file_name = &#39;mvbep_summaries/office-boulder_init-summary&#39;)
    ```

    &#34;&#34;&#34; 
    if self.mvbep_state[&#39;mvbep&#39;] == &#39;NOT INITIATED&#39;:
        print(&#39;The MVBEP object has not been initiated. Initiate the model using fit_training().&#39;)
        sys.exit()
    elif self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] == &#39;FAILED INITIATION&#39;:
        print(&#34;The MVBEP object failed the initiation process. Fix the data and run fit_training()&#34;)
        sys.exit()
    else: 
        GenerateInitializationSummary(file_name = file_name,
            df_input                    = self.mvbep_state[&#39;initializer&#39;][&#39;cleaned_data&#39;],
            frequency                   = self.mvbep_state[&#39;initializer&#39;][&#39;frequency&#39;],
            features                    = self.mvbep_state[&#39;initializer&#39;][&#39;features&#39;],
            df_timestamps_highlights    = self.mvbep_state[&#39;initializer&#39;][&#39;df_timestamps_highlights&#39;],
            df_validation               = self.mvbep_state[&#39;initializer&#39;][&#39;df_validation&#39;],
            data_sufficiency            = self.mvbep_state[&#39;initializer&#39;][&#39;data_sufficiency&#39;])</code></pre>
</details>
</dd>
<dt id="mvbep.MVBEP.predict_energy_consumption"><code class="name flex">
<span>def <span class="ident">predict_energy_consumption</span></span>(<span>self, data:Â pandas.core.frame.DataFrame, generate_summary:Â boolÂ =Â False, file_name:Â strÂ =Â None, mismatch_date_threshold=0.3, total_missing=None, max_consec_missing=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates savings quantification summary after using <code>develop_mvbep()</code>.</p>
<p>Outputs an HTML file that summarizes the quantification process after running <code>develop_mvbep().</code>
The quantification process requires post-retrofit data that matches the same frequency and features
of the data used in initialization when running <code>fit_training()</code>. Features that was dropped in the
initialization process are not required in the post-retrofit data. To see which features passed the
initialization process, check the output of <code>generate_initialization_summary()</code>.</p>
<h2 id="parameters">Parameters</h2>
<p>data :pd.DataFrame
The post-retrofit data.
generate_summary :bool: (default False)
Either generates a summary in an HTML file or return a <code>list</code> of baseline energy consumption.
In case the passed <code>data</code> does not meet the requirements, an initialization summary is generated
regardless of the passed argument in <code>generate_summary</code>.</p>
<pre><code>- If True: A quantification summary is provided. The function does not return any object.
- If False: A list of baseline energy consumption for the provided post-retrofit period is 
returend.
</code></pre>
<dl>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str: (default None)</code></dt>
<dd>Sets the name of the HTML quantification summary. In case no name was provided,
the resulting name will be <code>initiation_time</code> + <code>quant_sum_</code>.</dd>
<dt><strong><code>mismatch_date_threshold</code></strong> :&ensp;<code>float: (default = 0.3)</code></dt>
<dd>Sets the threshold for values in <code>timestamp</code> column that cannot be converted from <code>str</code>
to <code>datetime</code> object.</dd>
<dt><strong><code>total_missing</code></strong> :&ensp;<code>int: (default</code>None<code>, The value is set based on frequency)</code></dt>
<dd>Sets a threshold for the total number of a feature's missing observations to meet
data sufficiency requirements.</dd>
<dt><strong><code>max_consec_missing</code></strong> :&ensp;<code>int: (default</code>None<code>, The value is set based on frequency)</code></dt>
<dd>Sets a threshold for consecutive missing observations in a single feature before
the feature is dropped.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Writing the quantification summary of <code>mvbep_boulder</code>.</p>
<pre><code>mvbep_boulder.predict_energy_consumption(data = df_boulder_post_retrofit,
                                        generate_summary = True,
                                        file_name='mvbep_summaries/office-boulder_dev-summary')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predict_energy_consumption(self,
                data:pd.DataFrame,
                generate_summary:bool = False,
                file_name:str = None,
                mismatch_date_threshold = 0.3,
                total_missing = None,
                max_consec_missing = None
    ):
    &#34;&#34;&#34; Generates savings quantification summary after using `develop_mvbep()`.

    Outputs an HTML file that summarizes the quantification process after running `develop_mvbep().`
    The quantification process requires post-retrofit data that matches the same frequency and features
    of the data used in initialization when running `fit_training()`. Features that was dropped in the
    initialization process are not required in the post-retrofit data. To see which features passed the 
    initialization process, check the output of `generate_initialization_summary()`.

    Parameters
    ----------
    data :pd.DataFrame 
        The post-retrofit data.
    generate_summary :bool: (default False)
        Either generates a summary in an HTML file or return a `list` of baseline energy consumption.
        In case the passed `data` does not meet the requirements, an initialization summary is generated
        regardless of the passed argument in `generate_summary`.

        - If True: A quantification summary is provided. The function does not return any object.
        - If False: A list of baseline energy consumption for the provided post-retrofit period is 
        returend.  
    file_name : str: (default None)
        Sets the name of the HTML quantification summary. In case no name was provided, 
        the resulting name will be `initiation_time` + `quant_sum_`.
    mismatch_date_threshold : float: (default = 0.3)
        Sets the threshold for values in `timestamp` column that cannot be converted from `str`
        to `datetime` object.  
    total_missing : int: (default `None`, The value is set based on frequency)
        Sets a threshold for the total number of a feature&#39;s missing observations to meet 
        data sufficiency requirements.
    max_consec_missing : int: (default `None`, The value is set based on frequency)
        Sets a threshold for consecutive missing observations in a single feature before
        the feature is dropped. 

    Example
    ----------
    Writing the quantification summary of `mvbep_boulder`.
    ```
    mvbep_boulder.predict_energy_consumption(data = df_boulder_post_retrofit,
                                            generate_summary = True,
                                            file_name=&#39;mvbep_summaries/office-boulder_dev-summary&#39;)
    ```


    &#34;&#34;&#34; 
    # Check MVBEP state
    if self.mvbep_state[&#39;mvbep&#39;][&#39;development_state&#39;] != &#39;DEVELOPED&#39;:
        print(&#39;The MVBEP object has not been developed. Develop the model using develop_mvbep.&#39;)
        sys.exit()

    # Initialization 
    mismatch_date_threshold
    initializer = Initializer(mvbep_state = self.mvbep_state,
                              mismatch_date_threshold = mismatch_date_threshold
                             )
    initializer.validate_pred_data(data = data,
                                   total_missing = total_missing, 
                                   max_consec_missing = max_consec_missing
                                  )

    # Transformation
    if initializer.initializer_state != &#39;INITIATED&#39;:
        print(&#39;The post-retrofit data failed the initialization process. Check the initialization summary.&#39;)
        GenerateQuantificationSummary(mvbep_state               = self.mvbep_state, 
                                      df_init                   = initializer.df_fin,
                                      df_savings                = None,
                                      df_timestamps_highlights  = initializer.df_timestamps_highlights,
                                      df_validation             = initializer.df_validation,
                                      data_sufficiency          = initializer.data_sufficiency,
                                      file_name                 = file_name)
        sys.exit()

    transformer = Transformer()
    data_frequency = initializer.frequency 
    best_frequency = self.mvbep_state[&#39;transformer&#39;][&#39;mvbep_frequency&#39;]
    downsample = None if  best_frequency == data_frequency else data_frequency+&#39;~&#39;+best_frequency
    transformer.fit(data                = initializer.df_fin, 
                    timestamp_frequency = initializer.frequency,
                    optional_features   = initializer.features,
                    occupancy_schedule  = initializer.occupancy_schedule,
                    country_code        = initializer.country_code,
                    downsample_from_to  = downsample)
    transformer.transform()

    # Predictions 
    best_model = self.mvbep_state[&#39;mvbep&#39;][&#39;best_model&#39;]
    pred_pipeline = self.mvbep_state[&#39;developer&#39;][&#39;training_outputs&#39;][&#39;frequency&#39;][best_frequency][&#39;models_dict&#39;][best_model][&#39;model&#39;][&#39;pipe&#39;]
    if best_model == &#39;LR_towt&#39;:
        baseline_pred = pred_pipeline.predict(transformer.design_matrix_features)
    else: 
        baseline_pred = pred_pipeline.predict(transformer.df_fin.loc[:, transformer.design_matrix_features])
    
    # Savings
    df_savings = transformer.df_fin.copy()
    df_savings.rename(columns={&#39;energy&#39;:&#39;acut_post_energy&#39;}, inplace=True)
    df_savings[&#39;base_post_energy&#39;] = baseline_pred 

    # Interpretation
    if generate_summary:
        if not best_model.startswith(&#39;LR&#39;):
            _ , local_shap_values = return_interpretation_data(mvbep_state=self.mvbep_state,
                                                            global_sample_size=1,
                                                            local_sample_size=df_savings.shape[0],
                                                            df_input = df_savings,
                                                            design_matrix_features= transformer.design_matrix_features)
            df_savings = local_shap_values

    # return df_savings

    # Summary 
    if generate_summary:
        GenerateQuantificationSummary(mvbep_state               = self.mvbep_state, 
                                      df_init                   = initializer.df_fin,
                                      df_savings                = df_savings,
                                      df_timestamps_highlights  = initializer.df_timestamps_highlights,
                                      df_validation             = initializer.df_validation,
                                      data_sufficiency          = initializer.data_sufficiency,
                                      file_name                 = file_name)
    else:
        return baseline_pred</code></pre>
</details>
</dd>
<dt id="mvbep.MVBEP.save_mvbep_state"><code class="name flex">
<span>def <span class="ident">save_mvbep_state</span></span>(<span>self, file_name:Â strÂ =Â None)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the current progress of the MVBEP object by storing <code>mvbep_state</code>.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>file_name</code></strong> :&ensp;<code>str: (default None)</code></dt>
<dd>Sets the name of the <code>Joblib</code> state file. In case no name was provided,
the resulting name will be <code>initiation_time</code> + <code>mvbep_state</code>.</dd>
</dl>
<h2 id="example">Example</h2>
<p>Saving the state of either an initiated MVBEP by <code>fit_training()</code> or a developed one by <code>develop_mvbep()</code>.</p>
<pre><code>mvbep.save_state('mvbep_states/office-boulder_mvbep-state')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_mvbep_state(self, file_name:str=None):
    &#34;&#34;&#34; Saves the current progress of the MVBEP object by storing `mvbep_state`.

    Parameters
    ----------
    file_name : str: (default None)
        Sets the name of the `Joblib` state file. In case no name was provided, 
        the resulting name will be `initiation_time` + `mvbep_state`.
        
    Example
    ----------
    Saving the state of either an initiated MVBEP by `fit_training()` or a developed one by `develop_mvbep()`.
    ```
    mvbep.save_state(&#39;mvbep_states/office-boulder_mvbep-state&#39;)
    ```


    &#34;&#34;&#34; 
    file_name = datetime.now().strftime(&#34;%Y%m%d-%H%M%S&#34;)+&#39;_mvbep_state&#39; if file_name is None else file_name
    with open(file_name, &#39;wb&#39;) as f:
        joblib.dump(self.mvbep_state, f, compress=5)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="mvbep.MVBEP" href="#mvbep.MVBEP">MVBEP</a></code></h4>
<ul class="">
<li><code><a title="mvbep.MVBEP.develop_mvbep" href="#mvbep.MVBEP.develop_mvbep">develop_mvbep</a></code></li>
<li><code><a title="mvbep.MVBEP.fit_training" href="#mvbep.MVBEP.fit_training">fit_training</a></code></li>
<li><code><a title="mvbep.MVBEP.generate_development_summary" href="#mvbep.MVBEP.generate_development_summary">generate_development_summary</a></code></li>
<li><code><a title="mvbep.MVBEP.generate_initialization_summary" href="#mvbep.MVBEP.generate_initialization_summary">generate_initialization_summary</a></code></li>
<li><code><a title="mvbep.MVBEP.predict_energy_consumption" href="#mvbep.MVBEP.predict_energy_consumption">predict_energy_consumption</a></code></li>
<li><code><a title="mvbep.MVBEP.save_mvbep_state" href="#mvbep.MVBEP.save_mvbep_state">save_mvbep_state</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>